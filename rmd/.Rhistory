ctd <- ctd[order(ctd$Cruise, ctd$Station),]
ctd[, c("Depth", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
names(ctd)
str(ctd)
ctd[, c("Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
sed
# Calculate porosity
# Pore space volume using pore water mass bottom water density
# Fill in seawater desnity for sites not having CTD data
library(seacarb)
dens <- ctd$Density
env <- cbind(ctd[, c("Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")],
sed[, c("Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")])
env
dens <- env$Density
vp <- (env$WW-env$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- env$DW/2.65
env$Porosity <- vp/(vp+vb)
env
View(env)
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
ctd <- ctd[order(ctd$Cruise, ctd$Station),]
names(ctd)
env <- cbind(ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")], sed[, c("Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")])
View(env)
ctd <- ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
ctd
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
names(sed)
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
sed
col_types <- c("text", "text", "text", "numeric", "numeric", "text", "text", "text", "text", "text", "text",
"numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text")
mac <- NULL
for(i in 1:15){
d <- read_excel("../excel/GPSC_macro_size_2020.08.03.xlsx", sheet=i, col_types=col_types)
mac <- rbind(mac, d)
}
mac <- as.data.frame(mac)
depth <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
mac <- cbind(depth[match(paste(mac$Cruise, mac$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mac)
mac$Wt <- mac$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100, 2000, 3700)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100", "1100-2000", "2000-3700")
mac$Depth.zone <- cut(mac$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by polychaetes, nematods, harpacticoids, peracarids and others
Category <- as.character(mac$Taxon)
Category[Category=="Amphipoda"|Category=="Cumacea"|Category=="Isopoda"|Category=="Tanaidacea"] <- "Peracarida"
Category[Category=="Oligochaeta"|Category=="Nemertea"|Category=="Sipuncula"|Category=="Aplacophora"|Category=="Ostracoda"] <- "Others"
mac <- cbind(Category, mac)
mac <- subset(mac, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132" & Station=="GS1"))
# Size (complete specimen)
mac_c <- subset(mac, Condition=="C")
# Observed macrofauna sizes
ggplot(data=mac_c,
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Observed polychaete sizes
ggplot(data=subset(mac_c, Category=="Polychaeta"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise, scales="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Which taxa has fragment specimen?
unique(subset(mac, Condition!="C")$Taxon)
# How many complete specimens in polychaetes and ophiuroids
# Polychaetes
subset(mac, Taxon=="Polychaeta" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Polychaeta")$Size %>% length
# Ophiuroids
subset(mac, Taxon=="Ophiuroidea" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Ophiuroidea")$Size %>% length
# Size (complete macrofauna specimen)
mac_c <- subset(mac, Condition=="C")
mac_c <- splitBy(~Taxon+Cruise+Station+Deployment+Tube, mac_c)
# Abundance (specimen with head)
mac_a <- subset(mac, !(Condition=="F" | is.na(Condition)))
mac_a <- summaryBy(Wt~Taxon+Cruise+Station+Deployment+Tube, data=mac_a, FUN=length, var.names="Abundance", keep.names=TRUE)
# Average by Cruise/Station and then scale the abundance to 3 multicore tubes
#mac_a <- summaryBy(Abundance~Category+Cruise+Station, data=mac_a, FUN=mean, var.names="Abundance", keep.names=TRUE)
#mac_a$Abundance <- mac_a$Abundance*3
# Total abundce in each sample
sn <- with(mac_a, paste(Taxon, Cruise, Station, Deployment, Tube, sep="|"))
abund <- mac_a[match(names(mac_c), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mac_c[[i]])[1], si=abund[i], replace=TRUE)
mac_c[[i]][keep,]
}
# Only Polychaeta and Ophiuroidea needs to be resampled
keep <- grep("Polychaeta|Ophiuroidea", names(mac_c))
# Simulated Polychaeta and Ophiuroidea size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Polychaeta and Ophiuroidea data
for(i in 1:length(keep)) mac_c[[keep[i]]] <- simu[[i]]
ggplot(data=ldply(mac_c),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
mac_s <- ldply(mac_c, .id=NULL)
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc
match(with(sed, paste(Cruise, Station, Depolyment)), with(depth, paste(Cruise, Station, Depolyment)))
match(with(sed, paste(Cruise, Station, Depolyment)), with(depth, paste(Cruise, Station, Deployment)))
match(with(sed, paste(Cruise, Station, Deployment)), with(depth, paste(Cruise, Station, Deployment)))
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
head(loc)
summaryBy(loc, Longitude+Latitude+Depth~Habitat+Cruise+Station, FUN=mean, keep.names = TRUE)
str(loc)
summaryBy(as.data.frame(loc), Longitude+Latitude+Depth~Habitat+Cruise+Station, FUN=mean, keep.names = TRUE)
summaryBy(Longitude+Latitude+Depth~Habitat+Cruise+Station, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
loc
sed
sed <- cbind(loc, sed[, -1:-2])
sed
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
sed <- cbind(loc, sed[, -1:-3])
sed
dens <- ctd$Density
vp <- (sed$WW-sed$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- sed$DW/2.65
sed$Porosity <- vp/(vp+vb)
sed
ctd
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(foreach)
library(doSNOW)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
strip.text=element_text(size=20),
axis.title = element_text(size=20),
axis.text.y = element_text(size=20),
axis.text.x = element_text(size=20, angle=60, hjust=0.5))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
tc
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
sed
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station, Deployment))
id2 <- with(sed, paste(Cruise, Station, Deployment))
tc <- tc[match(id2, id1), ]
head(tc)
tc
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station, Deployment))
id2 <- with(sed, paste(Cruise, Station, Deployment))
id1
id2
tc
tc <- subset(tc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
tc
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station))
id2 <- with(sed, paste(Cruise, Station))
tc <- tc[match(id2, id1), ]
tc
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
ctd <- ctd[order(ctd$Cruise, ctd$Station),]
ctd <- ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station))
id2 <- with(sed, paste(Cruise, Station))
tc <- tc[match(id2, id1), ]
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
sed <- cbind(loc, sed[, -1:-3])
# Calculate porosity
# Pore space volume using pore water mass bottom water density
# Fill in seawater desnity for sites not having CTD data
library(seacarb)
dens <- ctd$Density
vp <- (sed$WW-sed$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- sed$DW/2.65
sed$Porosity <- vp/(vp+vb)
loc
head(sed)
sed[,-1:-7]
tc
env <- cbind(loc, sed[,-1:-7], tc[, -1:-3])
env
names(tc)
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station))
id2 <- with(sed, paste(Cruise, Station))
tc <- tc[match(id2, id1), c("Speed.mean", "Speed.max", "over20")]
env <- cbind(loc, sed[,-1:-7], tc[, -1:-3])
head(env)
tc
env <- cbind(loc, sed[,-1:-7], tc)
env
save(env, file="../data/env.rda")
knitr::opts_chunk$set(echo = TRUE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(doSNOW)
library(foreach)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
strip.text=element_text(size=20),
axis.title = element_text(size=20),
axis.text.y = element_text(size=20),
axis.text.x = element_text(size=20, angle=60, hjust=0.5))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# Size (complete macrofauna specimen)
mac_c <- subset(mac, Condition=="C")
mac_c <- splitBy(~Category+Cruise+Station, mac_c)
# Abundance (specimen with head)
mac_a <- subset(mac, !(Condition=="F" | is.na(Condition)))
mac_a <- summaryBy(Taxon~Category+Cruise+Station+Deployment+Tube, data=mac_a, FUN=length, var.names="Abundance", keep.names=TRUE)
# Average by Cruise/Station and then scale the abundance to 1 multicore tubes
mac_a <- summaryBy(Abundance~Category+Cruise+Station, data=mac_a, FUN=mean, var.names="Abundance", keep.names=TRUE)
mac_a$Abundance <- mac_a$Abundance
mac_a$Abundance
# Total abundance in each sample
sn <- with(mac_a, paste(Category, Cruise, Station, sep="|"))
abund <- mac_a[match(names(mac_c), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mac_c[[i]])[1], si=abund[i], replace=TRUE)
mac_c[[i]][keep,]
}
# Simulated macrofauna size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=1:length(mac_c)) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
ggplot(data=ldply(simu),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise, scales="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
mac_s <- ldply(simu)
# Only show 1096, 1114, 1126 macrofauna size simulation because only these cruise have ok polychaete sizes
ggplot(data=subset(mac_s, Cruise=="OR1_1096"|Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise, scales="free_y")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda"&Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
mei_a <- summaryBy(Abundance~Category+Cruise+Station+Taxon, data=mei_a, FUN=c(mean, sd, length), keep.names=T)
names(mei_a)[5:7] <- c("Abundance", "sd", "n")
# Scale the meiofauna abundance to the area of 1 multicore tube
mei_a$Abundance <- round(mei_a$Abundance*(10.5/2)^2/(2.5/2)^2)
mei_a$sd <- round(mei_a$sd*(10.5/2)^2/(2.5/2)^2)
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, sep="|"))
mei <- splitBy(~Category+Cruise+Station, mei)
abund <- mei_a[match(names(mei), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei[[i]])[1], si=abund[i], replace=TRUE)
mei[[i]][keep,]
}
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=1:length(mei)) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
ggplot(data=subset(ldply(simu), Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
mei_s <- ldply(simu)
# OR1 1114, 1126
si <- merge(cbind(Class="Meiofauna", mei_s), cbind(Class="Macrofauna", mac_s), all=T)
si$Habitat <- factor(si$Habitat, levels=c("Canyon", "Slope"))
# Only use 1126 data in which the meiofauna data are available
si <- si[grep("1114|1126", si$Cruise),]
ggplot(data=subset(si, Category!="Others"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
facet_wrap(~Category, scales="free")+
scale_fill_manual(values=c("black", "gray"))+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% rotate #%+replace% dark
install.packages("sizeSpectra")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(devtools)
install_github("andrew-edwards/sizeSpectra")
library(doBy)
library(readxl)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
# Use functions from Edwards etal. (2017) Methods in Ecology and Evolution 1:57-67
# https://github.com/andrew-edwards/fitting-size-spectra
#source("PLBfunctions.r")
hab <- splitBy(~Habitat, data=subset(mac_s, Condition=="C"))
wt <- lapply(hab, FUN=function(x)x$Wt)
bks <- l2b(unlist(wt))
out <- lapply(wt, FUN=function(x)LBNbiom.method(x, binBreaks=bks))
nbss <- ldply(lapply(out, FUN=function(x)x$binVals), data.frame)
info <- ldply(strsplit(nbss$.id, split="[|]"))
names(info) <- c("Habitat")
nbss <- cbind(info, nbss[, -1])
ggplot(data=ldply(hab),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
ggplot(data=nbss,aes(x=log10binMid, y=log10totalBiom, colour=Habitat))+
geom_point(size=5)+
geom_path(size=1)+
scale_colour_manual(values=c("black","gray"))+
labs(x=expression(Log[10]~"mid-point of"~size~class~(mg)), y=expression(Log[10]~biomass~(mg~m^-2)))+
theme_bw() %+replace% large #%+replace% dark
ggplot(data=nbss,aes(x=log10binMid, y=log10totalBiomNorm, colour=Habitat))+
geom_point(size=5)+
geom_path(size=1)+
scale_colour_manual(values=c("black","gray"))+
labs(x=expression(Log[10]~"mid-point of"~size~class~(mg)), y=expression(Log[10]~normalized~biomass))+
theme_bw() %+replace% large #%+replace% dark
install.packages("doBy")
install.packages("dplyr")
install.packages(c("ape", "data.table", "DT", "fs", "prettydoc", "ps", "raster", "rgdal", "tidyr", "xfun"))
install.packages(c("ape", "data.table", "DT", "fs", "prettydoc", "ps", "raster", "rgdal", "tidyr", "xfun"))
install.packages(c("ape", "data.table", "DT", "fs", "prettydoc", "ps", "raster", "rgdal", "tidyr", "xfun"))
install.packages(c("ape", "data.table", "DT", "fs", "prettydoc", "ps", "raster", "rgdal", "tidyr", "xfun"))
install.packages(c("ape", "data.table", "DT", "fs", "prettydoc", "ps", "raster", "rgdal", "tidyr", "xfun"))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(dplyr)
library(doBy)
library(readxl)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
