library(ggrepel)
library(plyr)
library(doBy)
library(readxl)
library(reshape2)
library(vegan)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
#library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
bks <- l2b(c(mei_s$Wt, mac_s$Wt))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(ggrepel)
library(plyr)
library(doBy)
library(readxl)
library(reshape2)
library(vegan)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
#library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
bks <- l2b(c(mei_s$Wt, mac_s$Wt))
mei_s$Class <- cut(mei_s$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
mei_sc <- acast(mei_s, Cruise+Habitat+Station+Deployment+Tube+Subcore~Class, value.var = "Wt", fun.aggregate=sum)
fr <- strsplit(row.names(mei_sc), split="_") %>%ldply
fr <- cbind(paste(fr$V1, fr$V2, sep="_"), fr[,-1:-2])
names(fr) <- c("Cruise", "Habitat", "Station", "Deployment", "Tube", "Subcore")
mei_md <- metaMDS(mei_sc, distance = "bray")
stress <- paste("Stress = ", deparse(round(mei_md$stress,2)))
wa <- wascores(mei_md$points, mei_sc) %>% as.data.frame
wa$label <- row.names(wa) %>% as.numeric
ggplot(data=cbind(mei_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mei_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-2, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
mac_s$Class <- cut(mac_s$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
mac_sc <- acast(mac_s, Cruise+Habitat+Station+Deployment+Tube~Class, value.var = "Wt", fun.aggregate=sum)
fr <- strsplit(row.names(mac_sc), split="_") %>%ldply
fr <- cbind(paste(fr$V1, fr$V2, sep="_"), fr[,-1:-2])
names(fr) <- c("Cruise", "Habitat", "Station", "Deployment", "Tube")
mac_md <- metaMDS(mac_sc, distance = "bray")
stress <- paste("Stress = ", deparse(round(mac_md$stress,2)))
wa <- wascores(mac_md$points, mac_sc) %>% as.data.frame
wa$label <- row.names(wa) %>% as.numeric
ggplot(data=cbind(mac_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mac_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-2, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
ggplot(data=cbind(mac_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mac_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-1.5, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
mac_s$Condition
table(mac_s$Condition)
table(mac$Condition)
table(mei$Condition)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(ggrepel)
library(plyr)
library(doBy)
library(readxl)
library(reshape2)
library(vegan)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
#library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
bks <- l2b(c(mei$Wt, subset(mac, Condition=="C")$Wt))
mei_s$Class <- cut(mei_s$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
mei_sc <- acast(mei_s, Cruise+Habitat+Station+Deployment+Tube+Subcore~Class, value.var = "Wt", fun.aggregate=sum)
fr <- strsplit(row.names(mei_sc), split="_") %>%ldply
fr <- cbind(paste(fr$V1, fr$V2, sep="_"), fr[,-1:-2])
names(fr) <- c("Cruise", "Habitat", "Station", "Deployment", "Tube", "Subcore")
mei_md <- metaMDS(mei_sc, distance = "bray")
stress <- paste("Stress = ", deparse(round(mei_md$stress,2)))
wa <- wascores(mei_md$points, mei_sc) %>% as.data.frame
wa$label <- row.names(wa) %>% as.numeric
ggplot(data=cbind(mei_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mei_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-2, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
mac_s$Class <- cut(mac_s$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
mac_sc <- acast(subset(mac, Condition=="C"), Cruise+Habitat+Station+Deployment+Tube~Class, value.var = "Wt", fun.aggregate=sum)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(ggrepel)
library(plyr)
library(doBy)
library(readxl)
library(reshape2)
library(vegan)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
#library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
bks <- l2b(c(mei_s$Wt, mac$Wt))
mei_s$Class <- cut(mei_s$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
mei_sc <- acast(mei_s, Cruise+Habitat+Station+Deployment+Tube+Subcore~Class, value.var = "Wt", fun.aggregate=sum)
fr <- strsplit(row.names(mei_sc), split="_") %>%ldply
fr <- cbind(paste(fr$V1, fr$V2, sep="_"), fr[,-1:-2])
names(fr) <- c("Cruise", "Habitat", "Station", "Deployment", "Tube", "Subcore")
mei_md <- metaMDS(mei_sc, distance = "bray")
stress <- paste("Stress = ", deparse(round(mei_md$stress,2)))
wa <- wascores(mei_md$points, mei_sc) %>% as.data.frame
wa$label <- row.names(wa) %>% as.numeric
ggplot(data=cbind(mei_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mei_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-2, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
mac$Class <- cut(mac$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
macc <- acast(mac, Cruise+Habitat+Station+Deployment+Tube~Class, value.var = "Wt", fun.aggregate=sum)
fr <- strsplit(row.names(macc), split="_") %>%ldply
fr <- cbind(paste(fr$V1, fr$V2, sep="_"), fr[,-1:-2])
names(fr) <- c("Cruise", "Habitat", "Station", "Deployment", "Tube")
mac_md <- metaMDS(macc, distance = "bray")
stress <- paste("Stress = ", deparse(round(mac_md$stress,2)))
wa <- wascores(mac_md$points, macc) %>% as.data.frame
wa$label <- row.names(wa) %>% as.numeric
ggplot(data=cbind(mac_md$points, fr), aes(x=MDS1, y=MDS2, fill=Habitat, colour=Habitat))+
geom_point(pch=21, alpha=0.8, size=5, colour=gray(0, 0.2))+
#geom_point(data=cbind(mac_md$points, fr) %>% subset(Cruise=="OR1_1114"), pch=21, size=2, fill="white", colour="black")+
stat_ellipse(type="norm")+
annotate("text", x=-1.5, y=1.5, label=stress, size=5) +
geom_label_repel(data=wa, aes(x=MDS1, y=MDS2, label=label), colour="black",
fill=gray(1, 0.6), size=4, label.padding = unit(0.2, "lines"), parse = TRUE)+
theme_bw() %+replace% large
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(ggrepel)
library(plyr)
library(doBy)
library(readxl)
library(reshape2)
library(vegan)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
#library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
bks <- l2b(c(mei_s$Wt, subset(mac, Condition=="C)$Wt))
subset(mac, Condition=="C)$Class <- cut(subset(mac, Condition=="C)$Wt, breaks=bks, labels=log10((bks[-28]+bks[-1])/2) %>% round(digits = 1))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
setwd("D:/GitHub/bbbs/rmd")
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(foreach)
library(doSNOW)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
strip.text=element_text(size=20),
axis.title = element_text(size=20),
axis.text.y = element_text(size=20),
axis.text.x = element_text(size=20, angle=60, hjust=0.5))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
head(ctd)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|Cruise=="OR1_1132")
head(ctd)
View(ctd)
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
head(ctd)
View(ctd)
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 9))
sed <- as.data.frame(read_excel("../GPSC_data/GPSC_sediment/GPSC_sediment_2019.5.11.xlsx", sheet=1, col_types=col_types))
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 9))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
View(sed)
order(sed$Cruise, sed$Station)
sed <- sed[order(sed$Cruise, sed$Station),]
View(sed)
ctd <- ctd[order(ctd$Cruise, ctd$Station),]
ctd[, c("Depth", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
names(ctd)
str(ctd)
ctd[, c("Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
sed
# Calculate porosity
# Pore space volume using pore water mass bottom water density
# Fill in seawater desnity for sites not having CTD data
library(seacarb)
dens <- ctd$Density
env <- cbind(ctd[, c("Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")],
sed[, c("Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")])
env
dens <- env$Density
vp <- (env$WW-env$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- env$DW/2.65
env$Porosity <- vp/(vp+vb)
env
View(env)
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
ctd <- ctd[order(ctd$Cruise, ctd$Station),]
names(ctd)
env <- cbind(ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")], sed[, c("Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")])
View(env)
ctd <- ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
ctd
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
names(sed)
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
sed
col_types <- c("text", "text", "text", "numeric", "numeric", "text", "text", "text", "text", "text", "text",
"numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text")
mac <- NULL
for(i in 1:15){
d <- read_excel("../excel/GPSC_macro_size_2020.08.03.xlsx", sheet=i, col_types=col_types)
mac <- rbind(mac, d)
}
mac <- as.data.frame(mac)
depth <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
mac <- cbind(depth[match(paste(mac$Cruise, mac$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mac)
mac$Wt <- mac$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100, 2000, 3700)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100", "1100-2000", "2000-3700")
mac$Depth.zone <- cut(mac$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by polychaetes, nematods, harpacticoids, peracarids and others
Category <- as.character(mac$Taxon)
Category[Category=="Amphipoda"|Category=="Cumacea"|Category=="Isopoda"|Category=="Tanaidacea"] <- "Peracarida"
Category[Category=="Oligochaeta"|Category=="Nemertea"|Category=="Sipuncula"|Category=="Aplacophora"|Category=="Ostracoda"] <- "Others"
mac <- cbind(Category, mac)
mac <- subset(mac, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132" & Station=="GS1"))
# Size (complete specimen)
mac_c <- subset(mac, Condition=="C")
# Observed macrofauna sizes
ggplot(data=mac_c,
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Observed polychaete sizes
ggplot(data=subset(mac_c, Category=="Polychaeta"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise, scales="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Which taxa has fragment specimen?
unique(subset(mac, Condition!="C")$Taxon)
# How many complete specimens in polychaetes and ophiuroids
# Polychaetes
subset(mac, Taxon=="Polychaeta" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Polychaeta")$Size %>% length
# Ophiuroids
subset(mac, Taxon=="Ophiuroidea" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Ophiuroidea")$Size %>% length
# Size (complete macrofauna specimen)
mac_c <- subset(mac, Condition=="C")
mac_c <- splitBy(~Taxon+Cruise+Station+Deployment+Tube, mac_c)
# Abundance (specimen with head)
mac_a <- subset(mac, !(Condition=="F" | is.na(Condition)))
mac_a <- summaryBy(Wt~Taxon+Cruise+Station+Deployment+Tube, data=mac_a, FUN=length, var.names="Abundance", keep.names=TRUE)
# Average by Cruise/Station and then scale the abundance to 3 multicore tubes
#mac_a <- summaryBy(Abundance~Category+Cruise+Station, data=mac_a, FUN=mean, var.names="Abundance", keep.names=TRUE)
#mac_a$Abundance <- mac_a$Abundance*3
# Total abundce in each sample
sn <- with(mac_a, paste(Taxon, Cruise, Station, Deployment, Tube, sep="|"))
abund <- mac_a[match(names(mac_c), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mac_c[[i]])[1], si=abund[i], replace=TRUE)
mac_c[[i]][keep,]
}
# Only Polychaeta and Ophiuroidea needs to be resampled
keep <- grep("Polychaeta|Ophiuroidea", names(mac_c))
# Simulated Polychaeta and Ophiuroidea size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Polychaeta and Ophiuroidea data
for(i in 1:length(keep)) mac_c[[keep[i]]] <- simu[[i]]
ggplot(data=ldply(mac_c),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
mac_s <- ldply(mac_c, .id=NULL)
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc
match(with(sed, paste(Cruise, Station, Depolyment)), with(depth, paste(Cruise, Station, Depolyment)))
match(with(sed, paste(Cruise, Station, Depolyment)), with(depth, paste(Cruise, Station, Deployment)))
match(with(sed, paste(Cruise, Station, Deployment)), with(depth, paste(Cruise, Station, Deployment)))
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
head(loc)
summaryBy(loc, Longitude+Latitude+Depth~Habitat+Cruise+Station, FUN=mean, keep.names = TRUE)
str(loc)
summaryBy(as.data.frame(loc), Longitude+Latitude+Depth~Habitat+Cruise+Station, FUN=mean, keep.names = TRUE)
summaryBy(Longitude+Latitude+Depth~Habitat+Cruise+Station, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
loc
sed
sed <- cbind(loc, sed[, -1:-2])
sed
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126"|Cruise=="OR1_1128"|(Cruise=="OR1_1132"&Station=="GS1"))
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
sed <- cbind(loc, sed[, -1:-3])
sed
dens <- ctd$Density
vp <- (sed$WW-sed$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- sed$DW/2.65
sed$Porosity <- vp/(vp+vb)
sed
ctd
