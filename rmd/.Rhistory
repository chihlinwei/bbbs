aes(x=Depth, y=daily.RtoM,
ymin=daily.RtoM-daily.RtoM.se, ymax=daily.RtoM+daily.RtoM.se,
shape=Habitat, colour=Habitat, fill=Habitat, linetype=Habitat))+
geom_point(size=5, position="jitter")+
stat_smooth(method="lm", formula=y~x, alpha=0.2)+
geom_errorbar(linetype=1, position="dodge")+
scale_colour_manual(values=c("#e41a1c", "#4daf4a"))+
scale_fill_manual(values=c("#e41a1c", "#4daf4a"))+
scale_linetype_manual(values=c(1,2))+
scale_shape_manual(values=c(19,1))+
labs(x="Depth (m)", y=expression("Mass-specific"~respiration~(day^-1)))+
theme_bw() %+replace% large #%+replace% dark
splitBy(~Habitat, out) %>% lapply(FUN=function(x)lm(daily.RtoM~Depth, data=x) %>% summary)
ggplot(data=out,
aes(x=Depth, y=daily.RtoM,
ymin=daily.RtoM-daily.RtoM.se, ymax=daily.RtoM+daily.RtoM.se,
shape=Habitat, colour=Habitat, fill=Habitat, linetype=Habitat))+
geom_point(size=5, position="jitter")+
stat_smooth(method="lm", formula=y~x, alpha=0.2)+
geom_errorbar(linetype=1, position="jitter")+
scale_colour_manual(values=c("#e41a1c", "#4daf4a"))+
scale_fill_manual(values=c("#e41a1c", "#4daf4a"))+
scale_linetype_manual(values=c(1,2))+
scale_shape_manual(values=c(19,1))+
labs(x="Depth (m)", y=expression("Mass-specific"~respiration~(day^-1)))+
theme_bw() %+replace% large #%+replace% dark
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(bbbs)
mac
subset(mac, Cruise="OR1_1102" & Station=="GS4")
subset(mac, Cruise="OR1_1102" & Station=="GS4")
subset(mac, Cruise=="OR1_1102" & Station=="GS4")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(knitr)
library(swtmap)
library(TWBathyMap)
library(maptools)
library(nlme)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
jet.colors <-colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
# Convert the numbers of polychaete specimen (with head) to abundance
pols <- subset(mac, Taxon=="Polychaeta" & (Condition=="FH" | Condition=="C" | Condition=="FHT"))
pola <- summaryBy(Size~Cruise+Station+Deployment+Tube+Taxon, data=pols, FUN=length, var.names="Abundance", keep.names = T)
pola <- cbind(pola[, 1:4], Section="0-15", pola[, 5:6], Comment="")
# Replace polycahete sorting abundance with correct abundance from size data
sort <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=2)
sort <- rbind(subset(sort, Taxon!="Polychaeta"), pola)
# Remove Cyclopoida and Calanoida
sort <- subset(sort, !(Taxon=="Cyclopoida"|Taxon=="Calanoida"))
# Total abundance by tube
abun <- summaryBy(Abundance~Cruise+Station+Deployment+Tube, data=as.data.frame(sort), FUN=sum, keep.names = TRUE)
depth <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
abun <- cbind(depth[match(paste(abun$Cruise, abun$Station), paste(depth$Cruise, depth$Station)),], Abundance=abun$Abundance)
dat <- subset(abun, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
# Remove outlier samples with only 1 individuals
bad <- with(dat, Abundance <=1 | (Cruise=="OR1_1102" & Station == "GS4") )
bad
which(bad)
dat[bad,]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(swtmap)
library(maptools)
library(knitr)
library(nlme)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
jet.colors <-colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
# Sorting data
abun   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
abun <- subset(abun, Cruise!="OR1_1128" & Cruise!="OR1_1132")
abun <- summaryBy(Abundance~Cruise+Station+Station+Deployment+Tube+Subcore, data=as.data.frame(abun), FUN=sum, keep.names=T)
abun$Density <- abun$Abundance/(pi*(2.5/2)^2/10000)
dat.mean <- summaryBy(Density~Cruise+Station, data=abun, FUN=c(mean, sd, length), keep.names = TRUE)
dat.mean$Density.se <- dat.mean$Density.sd/dat.mean$Density.length^0.5
cord   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=1)
keep <- match(paste(dat.mean$Cruise, dat.mean$Station), paste(cord$Cruise, cord$Station))
dat.mean<- cbind(cord[keep, 3:9], dat.mean[, 3:6])
names(dat.mean)[8:11] <- c("Density", "sd", "n", "se")
#dat.mean$Longitude <- round(dat.mean$Longitude, 4)
#dat.mean$Latitude <- round(dat.mean$Latitude, 4)
#dat.mean$Depth <- round(dat.mean$Depth, 0)
#dat.mean$Density <- round(dat.mean$Density, 0)
#dat.mean$sd <- round(dat.mean$sd, 1)
#dat.mean$se <- round(dat.mean$se, 1)
kable(dat.mean, align="c")
splitBy(~Habitat, dat.mean) %>% lapply(FUN=function(x)lm(log10(Density)~Depth, data=x) %>% summary)
ggplot(data= dat.mean,
aes(x=Depth, y=log10(Density), ymin=log10(Density-se), ymax=log10(Density+se), colour=Habitat, linetype=Habitat, shape=Habitat))+
geom_point(size=5)+
scale_shape_manual(values=c(19,1))+
geom_errorbar(linetype=1)+
#stat_smooth(method="lm", formula=y~x, alpha=0.2)+
scale_colour_manual(values=c("#e41a1c", "#4daf4a"))+
scale_shape_manual(values=c(19, 1))+
scale_linetype_manual(values=c(1,2))+
labs(x="Depth (m)", y=expression(Log[10]~density~(indiv~m^-2)))+
#scale_y_log10()+
theme_bw() %+replace% large
f <- gls(log10(Density) ~ Habitat+Depth+Cruise+Habitat:Depth+Habitat:Cruise+Depth:Cruise, data=dat.mean, method = "REML")
kable(summary(f)$tTable)
summary(f)
f
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(knitr)
library(swtmap)
library(TWBathyMap)
library(maptools)
library(nlme)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
jet.colors <-colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
# Convert the numbers of polychaete specimen (with head) to abundance
pols <- subset(mac, Taxon=="Polychaeta" & (Condition=="FH" | Condition=="C" | Condition=="FHT"))
pola <- summaryBy(Size~Cruise+Station+Deployment+Tube+Taxon, data=pols, FUN=length, var.names="Abundance", keep.names = T)
pola <- cbind(pola[, 1:4], Section="0-15", pola[, 5:6], Comment="")
# Replace polycahete sorting abundance with correct abundance from size data
sort <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=2)
sort <- rbind(subset(sort, Taxon!="Polychaeta"), pola)
# Remove Cyclopoida and Calanoida
sort <- subset(sort, !(Taxon=="Cyclopoida"|Taxon=="Calanoida"))
# Total abundance by tube
abun <- summaryBy(Abundance~Cruise+Station+Deployment+Tube, data=as.data.frame(sort), FUN=sum, keep.names = TRUE)
depth <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
abun <- cbind(depth[match(paste(abun$Cruise, abun$Station), paste(depth$Cruise, depth$Station)),], Abundance=abun$Abundance)
dat <- subset(abun, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
# Remove outlier samples with only 1 individuals
bad <- with(dat, Abundance <=1 | (Cruise=="OR1_1102" & Station == "GS4") )
dat <- subset(dat, !bad)
dat$Density <- dat$Abundance/dat$Area
dat.mean <- summaryBy(Density+Longitude+Latitude+Depth+Date~Habitat+Cruise+Station, data=dat, FUN=c(mean, sd, length))
dat.mean$Date.mean <- strftime(as.POSIXct(dat.mean$Date.mean, origin = "1970-01-01", tz = "Asia/Taipei"), format="%Y-%m-%d")
dat.mean$Density.se <- dat.mean$Density.sd/dat.mean$Density.length^0.5
out <- dat.mean[, c("Habitat", "Cruise", "Station", "Longitude.mean", "Latitude.mean", "Depth.mean", "Date.mean", "Density.length", "Density.mean", "Density.sd", "Density.se")]
names(out) <- c("Habitat", "Cruise", "Station", "Longitude", "Latitude", "Depth", "Date", "n", "Density", "sd", "se")
#out$Longitude <- round(out$Longitude, 4)
#out$Latitude <- round(out$Latitude, 4)
#out$Depth <- round(out$Depth, 0)
#out$Density <- round(out$Density, 0)
#out$sd <- round(out$sd, 1)
#out$se <- round(out$se, 1)
kable(out, align="c", caption="OR1_1102 GS4, OR1_1126 GC2, and OR1_1126 GC3 Tube 2 had very low abundance and only single replication. They are removed as outliers before plotting")
splitBy(~Habitat, out) %>% lapply(FUN=function(x)lm(log10(Density)~Depth, data=x) %>% summary)
ggplot(data=out,
aes(x=Depth, y=log10(Density),
ymin=log10(Density-se), ymax=log10(Density+se),
colour=Habitat, fill=Habitat, linetype=Habitat,
shape=Habitat))+
geom_point(size=5, position = "dodge")+
stat_smooth(data=subset(out, Habitat=="Canyon"), method="lm", formula=y~x, alpha=0.2)+
geom_errorbar(linetype=1, position = "dodge")+
scale_colour_manual(values=c("#e41a1c", "#4daf4a"))+
scale_fill_manual(values=c("#e41a1c", "#4daf4a"))+
scale_linetype_manual(values=c(1,2))+
scale_shape_manual(values=c(19,1))+
labs(x="Depth (m)", y=expression(Log[10]~density~(ind~m^-2)))+
#scale_y_log10()+
theme_bw() %+replace% large #%+replace% dark
f <- gls(log10(Density) ~ Habitat+Depth+Cruise+Habitat:Depth+Habitat:Cruise+Depth:Cruise, data=out, method = "REML")
kable(summary(f)$tTable)
kable(anova(f))
summary(anova(f))
f
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(swtmap)
library(maptools)
library(knitr)
library(nlme)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
jet.colors <-colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
# Sorting data
abun   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
abun <- subset(abun, Cruise!="OR1_1128" & Cruise!="OR1_1132")
abun <- summaryBy(Abundance~Cruise+Station+Station+Deployment+Tube+Subcore, data=as.data.frame(abun), FUN=sum, keep.names=T)
abun$Density <- abun$Abundance/(pi*(2.5/2)^2/10000)
dat.mean <- summaryBy(Density~Cruise+Station, data=abun, FUN=c(mean, sd, length), keep.names = TRUE)
dat.mean$Density.se <- dat.mean$Density.sd/dat.mean$Density.length^0.5
cord   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=1)
keep <- match(paste(dat.mean$Cruise, dat.mean$Station), paste(cord$Cruise, cord$Station))
dat.mean<- cbind(cord[keep, 3:9], dat.mean[, 3:6])
names(dat.mean)[8:11] <- c("Density", "sd", "n", "se")
#dat.mean$Longitude <- round(dat.mean$Longitude, 4)
#dat.mean$Latitude <- round(dat.mean$Latitude, 4)
#dat.mean$Depth <- round(dat.mean$Depth, 0)
#dat.mean$Density <- round(dat.mean$Density, 0)
#dat.mean$sd <- round(dat.mean$sd, 1)
#dat.mean$se <- round(dat.mean$se, 1)
kable(dat.mean, align="c")
splitBy(~Habitat, dat.mean) %>% lapply(FUN=function(x)lm(log10(Density)~Depth, data=x) %>% summary)
ggplot(data= dat.mean,
aes(x=Depth, y=log10(Density), ymin=log10(Density-se), ymax=log10(Density+se), colour=Habitat, linetype=Habitat, shape=Habitat))+
geom_point(size=5)+
scale_shape_manual(values=c(19,1))+
geom_errorbar(linetype=1)+
#stat_smooth(method="lm", formula=y~x, alpha=0.2)+
scale_colour_manual(values=c("#e41a1c", "#4daf4a"))+
scale_shape_manual(values=c(19, 1))+
scale_linetype_manual(values=c(1,2))+
labs(x="Depth (m)", y=expression(Log[10]~density~(indiv~m^-2)))+
#scale_y_log10()+
theme_bw() %+replace% large
f <- gls(log10(Density) ~ Habitat+Depth+Cruise+Habitat:Depth+Habitat:Cruise+Depth:Cruise, data=dat.mean, method = "REML")
kable(summary(f)$tTable)
kable(anova(f))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(foreach)
library(doSNOW)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
strip.text=element_text(size=20),
axis.title = element_text(size=20),
axis.text.y = element_text(size=20),
axis.text.x = element_text(size=20, angle=60, hjust=0.5))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
col_types <- c("text", "text", "text", "numeric", "numeric", "text", "text", "text", "text", "text", "text",
"numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text")
mac <- NULL
for(i in 1:15){
d <- read_excel("../excel/GPSC_macro_size_2020.08.03.xlsx", sheet=i, col_types=col_types)
mac <- rbind(mac, d)
}
mac <- as.data.frame(mac)
depth <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
mac <- cbind(depth[match(paste(mac$Cruise, mac$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mac)
mac$Wt <- mac$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100, 2000, 3700)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100", "1100-2000", "2000-3700")
mac$Depth.zone <- cut(mac$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by polychaetes, nematods, harpacticoids, peracarids and others
Category <- as.character(mac$Taxon)
Category[Category=="Amphipoda"|Category=="Cumacea"|Category=="Isopoda"|Category=="Tanaidacea"] <- "Peracarida"
Category[Category=="Oligochaeta"|Category=="Nemertea"|Category=="Sipuncula"|Category=="Aplacophora"|Category=="Ostracoda"] <- "Others"
mac <- cbind(Category, mac)
mac <- subset(mac, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
# Remove outlier samples with only 1 individuals
bad <- with(mac, (Cruise=="OR1_1102" & Station == "GC1" & Deployment == 2 & Tube ==1)|
(Cruise=="OR1_1102" & Station == "GS4" & Deployment == 1 & Tube ==1)|
(Cruise=="OR1_1102" & Station == "GC4" & Deployment == 1 & Tube ==12)|
(Cruise=="OR1_1126" & Station == "GC1" & Deployment == 1 & Tube ==8) |
(Cruise=="OR1_1126" & Station == "GC2" & Deployment == 1 & Tube ==4)|
(Cruise=="OR1_1126" & Station == "GC3" & Deployment == 1 & Tube ==2)
)
mac <- subset(mac, !bad)
# Size (complete specimen)
mac_c <- subset(mac, Condition=="C")
# Observed macrofauna sizes
ggplot(data=mac_c,
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Observed polychaete sizes
ggplot(data=subset(mac_c, Category=="Polychaeta"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise, scales="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
# Which taxa has fragment specimen?
unique(subset(mac, Condition!="C")$Taxon)
# How many complete specimens in polychaetes and ophiuroids
# Polychaetes
subset(mac, Taxon=="Polychaeta" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Polychaeta")$Size %>% length
# Ophiuroids
subset(mac, Taxon=="Ophiuroidea" & Condition == "C")$Size %>% length / subset(mac, Taxon=="Ophiuroidea")$Size %>% length
# Size (complete macrofauna specimen)
mac_c <- subset(mac, Condition=="C")
mac_c <- splitBy(~Taxon+Cruise+Station+Deployment+Tube, mac_c)
# Abundance (specimen with head)
mac_a <- subset(mac, !(Condition=="F" | is.na(Condition)))
mac_a <- summaryBy(Wt~Taxon+Cruise+Station+Deployment+Tube, data=mac_a, FUN=length, var.names="Abundance", keep.names=TRUE)
# Average by Cruise/Station and then scale the abundance to 3 multicore tubes
#mac_a <- summaryBy(Abundance~Category+Cruise+Station, data=mac_a, FUN=mean, var.names="Abundance", keep.names=TRUE)
#mac_a$Abundance <- mac_a$Abundance*3
# Total abundce in each sample
sn <- with(mac_a, paste(Taxon, Cruise, Station, Deployment, Tube, sep="|"))
abund <- mac_a[match(names(mac_c), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mac_c[[i]])[1], si=abund[i], replace=TRUE)
mac_c[[i]][keep,]
}
# Only Polychaeta and Ophiuroidea needs to be resampled
keep <- grep("Polychaeta|Ophiuroidea", names(mac_c))
# Simulated Polychaeta and Ophiuroidea size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Polychaeta and Ophiuroidea data
for(i in 1:length(keep)) mac_c[[keep[i]]] <- simu[[i]]
ggplot(data=ldply(mac_c),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_wrap(~Cruise)+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
mac_s <- ldply(mac_c, .id=NULL)
# Hapacticoid and others
col_types <- c("text", "text", "text", "numeric", "numeric", "numeric", "text","text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "text")
mei <- NULL
for(i in 1:3){
d <- as.data.frame(read_excel("../excel/GPSC_meio_size_2020.08.02.xlsx", sheet=i, col_types=col_types))
mei <- rbind(mei, d)
}
# Get water depth
mei <- cbind(depth[match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mei)
mei$Wt <- mei$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100")
mei$Depth.zone <- cut(mei$Depth, breaks=depth.bk, labels=depth.lab)
mei <- subset(mei, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
# Split the size data by nematods, harpacticoids and others
Category <- as.character(mei$Taxon)
Category[Category!="Nematoda"&Category!="Harpacticoida"] <- "Others"
mei <- splitBy(~Category+Cruise+Station, cbind(Category, mei))
mei <- ldply(mei, .id=NULL)
ggplot(data=mei,
aes(x=log(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category)+
labs(y="Frequency", x=expression(Log~body~size~(mg~individual^-1)))+
theme_bw()%+replace% large #%+replace% dark
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei_s), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
# Only Nematoda needs to be resampled
kp <- grep("Nematoda", names(mei_s))
# indentify nematode
id <- lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector
# Only simulate size data when the numbers of sorted nematodes > numbers of indentified nematodes
kp <- kp[abund[kp] > id[kp]]
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=kp) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Nematoda data
for(i in 1:length(kp)) mei_s[[kp[i]]] <- simu[[i]]
mei_s <- ldply(mei_s, .id=NULL)
ggplot(data=mei_s,
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large  #%+replace% dark
# CTD data
ctd <- as.data.frame(read_excel("../excel/GPSC_CTD_2020.07.23.xlsx", sheet=1))
ctd <- splitBy(~Cruise+Station, ctd)
# Function to get average of bottom 3 deepest CTD data
deep_fun <- function(x) {
dat <- x[order(x$pressure, decreasing=TRUE)[1:3],]
summaryBy(.~Cruise+Station, data=dat, keep.names=TRUE, na.rm=TRUE)
}
ctd <- lapply(ctd, FUN=deep_fun)
ctd <- ldply(ctd)[, -1]
ctd$transmissometer[ctd$transmissometer<=0] <- 0 # Set negtive transmissometer to zero
# Average temperature, sigma_theta and density
ctd$Temperature <- rowMeans(ctd[, c("temperature_T1", "temperature_T2")], na.rm=TRUE)
ctd$Salinity <- rowMeans(ctd[, c("salinity_T1C1", "salinity_T2C2")], na.rm=TRUE)
ctd$Sigma_theta <- rowMeans(ctd[, c("density_T1C1...11", "density_T2C2...12")], na.rm=TRUE)
ctd$Density <- rowMeans(ctd[, c("density_T1C1...13", "density_T2C2...14")], na.rm=TRUE)
ctd <- subset(ctd, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
ctd <- ctd[order(ctd$Cruise, ctd$Station),]
ctd <- ctd[, c("Cruise", "Station", "Latitude", "Longitude", "pressure", "Temperature", "Salinity", "Density", "Oxygen", "fluorometer", "transmissometer")]
# Sediment data
col_types <- c(rep("text", 2), "numeric", "text", rep("numeric", 13))
sed <- as.data.frame(read_excel("../excel/GPSC_sediment_2020.06.17.xlsx", sheet=1, col_types=col_types))
sed <- sed[sed$Section=="0-1",]
sed <- subset(sed, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
sed <- sed[order(sed$Cruise, sed$Station),]
sed <- sed[, c("Cruise", "Station", "Deployment", "Section", "Clay", "Silt", "Sand", "CN", "TOC", "TN", "WC", "WW", "DW")]
# Tidal current data
tc <- read.csv("../excel/GPSC_tidal_current.csv")
id1 <- with(tc, paste(Cruise, Station))
id2 <- with(sed, paste(Cruise, Station))
tc <- tc[match(id2, id1), c("Speed.mean", "Speed.max", "over20")]
loc <- read_excel("../excel/GPSC_macro_sorting_2020.07.31.xlsx", sheet=1)
loc <- subset(loc, Cruise=="OR1_1096"|Cruise=="OR1_1102"|Cruise=="OR1_1114"|Cruise=="OR1_1126")
loc <- summaryBy(Longitude+Latitude+Depth~Cruise+Station+Habitat, data=as.data.frame(loc), FUN=mean, keep.names = TRUE)
sed <- cbind(loc, sed[, -1:-3])
# Calculate porosity
# Pore space volume using pore water mass bottom water density
# Fill in seawater desnity for sites not having CTD data
library(seacarb)
dens <- ctd$Density
vp <- (sed$WW-sed$DW)/(dens/1000)
# Dry sediment volume assuming density of 2.65 g/cm3
vb <- sed$DW/2.65
sed$Porosity <- vp/(vp+vb)
env <- cbind(loc, ctd[,-1:-5], sed[,-1:-7], tc)
kable(env)
kable(env)
