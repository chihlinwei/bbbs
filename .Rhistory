d <- as.data.frame(read_excel("../excel/GPSC_meio_size_2020.01.07.xlsx", sheet=i, col_types=col_types))
mei <- rbind(mei, d)
}
# Get water depth
mei <- cbind(depth[match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station)), "Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve"], mei)
match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station))
names(depth)
# Hapacticoid and others
col_types <- c("text", "text", "text", "numeric", "numeric", "numeric", "text","text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "text")
mei <- NULL
for(i in 1:3){
d <- as.data.frame(read_excel("../excel/GPSC_meio_size_2020.01.07.xlsx", sheet=i, col_types=col_types))
mei <- rbind(mei, d)
}
# Get water depth
mei <- cbind(depth[match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mei)
mei$Wt <- mei$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100")
mei$Depth.zone <- cut(mei$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by nematods, harpacticoids and others
Category <- as.character(mei$Taxon)
Category[Category!="Nematoda"&Category!="Harpacticoida"] <- "Others"
mei <- splitBy(~Category+Cruise+Station, cbind(Category, mei))
mei <- ldply(mei, .id=NULL)
ggplot(data=subset(mei, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category)+
labs(y="Frequency", x=expression(Log~body~size~(mg~individual^-1)))+
theme_bw()%+replace% large #%+replace% dark
names(mac)
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
mei_a <- summaryBy(Abundance~Category+Cruise+Station+Taxon, data=mei_a, FUN=c(mean, sd, length), keep.names=T)
names(mei_a)[5:7] <- c("Abundance", "sd", "n")
names(mac_s)
?ldply
mac_s <- ldply(mac_c, .id=NULL)
mac_s <- ldply(mac_c, .id=NULL)
names(mac_s)
mei_a$Abundance
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
head(mei_a)
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
mei_a <- summaryBy(Abundance~Category+Cruise+Station+Deployment+Tube+Subcore+Taxon, data=mei_a, FUN=c(mean, sd, length), keep.names=T)
head(mei_a)
mei_a
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
mei_a
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
sn
mei <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
mei
names(mei)
match(names(mei), sn)
abund <- mei_a[match(names(mei), sn),]$Abundance
abund
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei))
keep
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Nematoda data
for(i in 1:length(keep)) mei[[keep[i]]] <- simu[[i]]
mei$Cruise
mei
ldply(mei)
ldply(mei)$Cruise
ggplot(data=subset(ldply(mei), Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Hapacticoid and others
col_types <- c("text", "text", "text", "numeric", "numeric", "numeric", "text","text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "text")
mei <- NULL
for(i in 1:3){
d <- as.data.frame(read_excel("../excel/GPSC_meio_size_2020.01.07.xlsx", sheet=i, col_types=col_types))
mei <- rbind(mei, d)
}
# Get water depth
mei <- cbind(depth[match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mei)
mei$Wt <- mei$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100")
mei$Depth.zone <- cut(mei$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by nematods, harpacticoids and others
Category <- as.character(mei$Taxon)
Category[Category!="Nematoda"&Category!="Harpacticoida"] <- "Others"
mei <- splitBy(~Category+Cruise+Station, cbind(Category, mei))
mei <- ldply(mei, .id=NULL)
ggplot(data=subset(mei, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category)+
labs(y="Frequency", x=expression(Log~body~size~(mg~individual^-1)))+
theme_bw()%+replace% large #%+replace% dark
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei), sn),]$Abundance
names(mei)
head(mei)
names(mei_s)
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei_s))
keep
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei[[i]])[1], si=abund[i], replace=TRUE)
mei[[i]][keep,]
}
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei_s))
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei[[i]])[1], si=abund[i], replace=TRUE)
mei[[i]][keep,]
}
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei_s))
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei[[i]][keep,]
}
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei_s))
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
# Only Nematoda needs to be resampled
keep <- grep("Nematoda", names(mei_s))
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=keep) %dopar% sample_fun(i)
keep
# Hapacticoid and others
col_types <- c("text", "text", "text", "numeric", "numeric", "numeric", "text","text", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "text")
mei <- NULL
for(i in 1:3){
d <- as.data.frame(read_excel("../excel/GPSC_meio_size_2020.01.07.xlsx", sheet=i, col_types=col_types))
mei <- rbind(mei, d)
}
# Get water depth
mei <- cbind(depth[match(paste(mei$Cruise, mei$Station), paste(depth$Cruise, depth$Station)), c("Region", "Date", "Longitude", "Latitude", "Depth", "Corer", "Area", "Sieve")], mei)
mei$Wt <- mei$Size*(1.13)
depth.bk <- c(200, 400, 600, 800, 1100)
depth.lab <- c("200-400", "400-600", "600-800", "800-1100")
mei$Depth.zone <- cut(mei$Depth, breaks=depth.bk, labels=depth.lab)
# Split the size data by nematods, harpacticoids and others
Category <- as.character(mei$Taxon)
Category[Category!="Nematoda"&Category!="Harpacticoida"] <- "Others"
mei <- splitBy(~Category+Cruise+Station, cbind(Category, mei))
mei <- ldply(mei, .id=NULL)
ggplot(data=subset(mei, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category)+
labs(y="Frequency", x=expression(Log~body~size~(mg~individual^-1)))+
theme_bw()%+replace% large #%+replace% dark
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei_s), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
# Only Nematoda needs to be resampled
kp <- grep("Nematoda", names(mei_s))
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=kp) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
1:length(keep)
i=1
mei_s[[keep[i]]]
simu[[i]]
# Replace with the simulated Nematoda data
for(i in 1:length(keep)) mei_s[[keep[i]]] <- simu[[i]]
ggplot(data=subset(ldply(mei), Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
ggplot(data=subset(ldply(mei_s), Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
mei_s <- ldply(mei_s, .id=NULL)
ggplot(data=mei_s,
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
mei$Cruise
uniqeu(mei$Cruise)
unique(mei$Cruise)
ggplot(data=subset(mei_s, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
ggplot(data=subset(mei_s, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei_s), sn),]$Abundance
abund
mei_s
lapply(mei_s, FUN=function(x)dim(x)[1])
lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist
lapply(mei_s, FUN=function(x)dim(x)[1])%>%as.vector
lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist
lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector
abund
abund[kp]
lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector[kp]
(lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector)[kp]
(lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector)[kp].abund[kp]
(lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector)[kp]>abund[kp]
(lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector)[kp]==abund[kp]
(lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector)[kp]<abund[kp]
# indentify nematode
id <- lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector
id
# indentify nematode
id <- lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector
id[kp]
abun[kp]
# Only simulate size when the numbers of sorted nematodes > numbers of indentified nematodes
abund[kp] > id[kp]
# Only simulate size when the numbers of sorted nematodes > numbers of indentified nematodes
kp[abund[kp] > id[kp]]
# Only simulate size data when the numbers of sorted nematodes > numbers of indentified nematodes
kp <- kp[abund[kp] > id[kp]]
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=kp) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Nematoda data
for(i in 1:length(keep)) mei_s[[keep[i]]] <- simu[[i]]
# Replace with the simulated Nematoda data
for(i in 1:length(kp)) mei_s[[kp[i]]] <- simu[[i]]
mei_s <- ldply(mei_s, .id=NULL)
ggplot(data=subset(mei_s, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei_s), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
abund > id
# Only simulate size data when the numbers of sorted > numbers of sized
kp <- which(abund > id)
kp
# Sorting data
mei_a   <- read_excel("../excel/GPSC_meio_sorting_2016.08.18.xlsx", sheet=2)
Category <- as.character(mei_a$Taxon)
Category[Category=="Copepoda"] <- "Harpacticoida"
Category[Category!="Nematoda" & Category!="Harpacticoida"] <- "Others"
mei_a <- cbind(Category, mei_a)
mei_a <- subset(mei_a, Subcore!="water")
# Match the sample names (tube) in size data to the sample names (tube) in sorting data
# Extract the total abudance from the sorting data
sn <- with(mei_a, paste(Category, Cruise, Station, Deployment, Tube, Subcore, sep="|"))
mei_s <- splitBy(~Category+Cruise+Station+Deployment+Tube+Subcore, mei)
abund <- mei_a[match(names(mei_s), sn),]$Abundance
# Resample the size data (with replacement) by the total abundance in each sample
sample_fun <-
function(i){
keep <- sample(1:dim(mei_s[[i]])[1], si=abund[i], replace=TRUE)
mei_s[[i]][keep,]
}
# Only Nematoda needs to be resampled
kp <- grep("Nematoda", names(mei_s))
# indentify nematode
id <- lapply(mei_s, FUN=function(x)dim(x)[1])%>%unlist%>%as.vector
# Only simulate size data when the numbers of sorted nematodes > numbers of indentified nematodes
kp <- kp[abund[kp] > id[kp]]
# Simulated size data
cl<-makeCluster(4) # change the 4 to your number of CPU cores
registerDoSNOW(cl) # register the SNOW parallel backend with the foreach package
simu <- foreach(i=kp) %dopar% sample_fun(i)
stopCluster(cl) # stop a SNOW cluster
# Replace with the simulated Nematoda data
for(i in 1:length(kp)) mei_s[[kp[i]]] <- simu[[i]]
mei_s <- ldply(mei_s, .id=NULL)
ggplot(data=subset(mei_s, Cruise=="OR1_1114"|Cruise=="OR1_1126"),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
facet_grid(Cruise~Category, scale="free")+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() #%+replace% dark
library(bbbs)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
#library(devtools)
#install_github("andrew-edwards/sizeSpectra")
library(sizeSpectra)
library(devtools)
install_github("andrew-edwards/sizeSpectra")
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
library(readxl)
library(devtools)
install_github("andrew-edwards/sizeSpectra")
library(sizeSpectra)
large <- theme(legend.title = element_text(size=20),
legend.text = element_text(size=20),
axis.title = element_text(size=20),
axis.text = element_text(size=20))
rotate <- theme(axis.text.x = element_text(size=20, angle=60, hjust=0.5))
# dark theme for ggplot
dark <- theme(plot.background = element_rect(colour = 'NA', fill = 'gray10'),
panel.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.background = element_rect(colour = 'NA', fill = 'transparent'),
legend.title = element_text(colour = 'white', size=20),
legend.text = element_text(colour = 'white', size=20),
axis.title = element_text(colour = 'white', size=20),
axis.text = element_text(colour = 'white', size=20),
axis.ticks = element_line(colour = 'white'),
panel.border = element_rect(fill = 'NA', colour = 'white'),
panel.grid.major = element_line(colour = 'gray30'),
panel.grid.minor = element_line(colour = 'gray20'))
# log2 bin
l2b <- function(x) 2^( floor(log2(min(x))) : ceiling(log2(max(x))) )
# Use functions from Edwards etal. (2017) Methods in Ecology and Evolution 1:57-67
# https://github.com/andrew-edwards/fitting-size-spectra
#source("PLBfunctions.r")
hab <- splitBy(~Habitat, data=subset(mac_s, Condition=="C"))
wt <- lapply(hab, FUN=function(x)x$Wt)
bks <- l2b(unlist(wt))
out <- lapply(wt, FUN=function(x)LBNbiom.method(x, binBreaks=bks))
nbss <- ldply(lapply(out, FUN=function(x)x$binVals), data.frame)
info <- ldply(strsplit(nbss$.id, split="[|]"))
names(info) <- c("Habitat")
nbss <- cbind(info, nbss[, -1])
ggplot(data=ldply(hab),
aes(x=log10(Wt), fill=Habitat))+
geom_density(alpha=0.5)+
scale_fill_manual(values=c("black", "gray"))+
labs(y="Frequency", x=expression(Log[10]~body~size~(mg)))+
theme_bw() %+replace% large #%+replace% dark
ggplot(data=nbss,aes(x=log10binMid, y=log10totalBiom, colour=Habitat))+
geom_point(size=5)+
geom_path(size=1)+
scale_colour_manual(values=c("black","gray"))+
labs(x=expression(Log[10]~"mid-point of"~size~class~(mg)), y=expression(Log[10]~biomass~(mg~m^-2)))+
theme_bw() %+replace% large #%+replace% dark
ggplot(data=nbss,aes(x=log10binMid, y=log10totalBiomNorm, colour=Habitat))+
geom_point(size=5)+
geom_path(size=1)+
scale_colour_manual(values=c("black","gray"))+
labs(x=expression(Log[10]~"mid-point of"~size~class~(mg)), y=expression(Log[10]~normalized~biomass))+
theme_bw() %+replace% large #%+replace% dark
install.packages(c("doBy", "purrr"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
install.packages(c("ade4", "backports", "bipartite", "broom", "callr", "car", "caret", "checkmate", "classInt", "covr", "crosstalk", "devtools", "digest", "dplyr", "DT", "fields", "forcats", "foreach", "fs", "ggplot2", "ggrepel", "glue", "gstat", "gtools", "igraph", "intervals", "knitr", "lava", "lme4", "lubridate", "mime", "ModelMetrics", "modelr", "MuMIn", "nloptr", "picante", "plotKML", "plyr", "Polychrome", "pROC", "processx", "ps", "quantreg", "Rcpp", "RcppArmadillo", "RcppProgress", "recipes", "remotes", "reshape2", "rlang", "roxygen2", "rstudioapi", "sf", "shiny", "sp", "spData", "SQUAREM", "StepReg", "stringi", "testthat", "tibble", "tinytex", "units", "usethis", "vctrs", "xfun", "xml2"))
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
install.packages("doBy")
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
install.packages("purrr")
library(bbbs)
library(ggplot2)
library(plyr)
library(doBy)
